package org.eclipse.vjet.vsf.dervlet.defaultdervs;

import org.eclipse.vjet.dsf.dom.DNode;
import org.eclipse.vjet.dsf.html.dom.BaseCoreHtmlElement;
import org.eclipse.vjet.dsf.html.dom.DBody;
import org.eclipse.vjet.dsf.html.dom.DDl;
import org.eclipse.vjet.dsf.html.dom.DDt;
import org.eclipse.vjet.dsf.html.dom.DFieldSet;
import org.eclipse.vjet.dsf.html.dom.DForm;
import org.eclipse.vjet.dsf.html.dom.DFrame;
import org.eclipse.vjet.dsf.html.dom.DFrameSet;
import org.eclipse.vjet.dsf.html.dom.DHead;
import org.eclipse.vjet.dsf.html.dom.DHtml;
import org.eclipse.vjet.dsf.html.dom.DHtmlDocument;
import org.eclipse.vjet.dsf.html.dom.DLi;
import org.eclipse.vjet.dsf.html.dom.DMap;
import org.eclipse.vjet.dsf.html.dom.DNoFrames;
import org.eclipse.vjet.dsf.html.dom.DObject;
import org.eclipse.vjet.dsf.html.dom.DOl;
import org.eclipse.vjet.dsf.html.dom.DOptGroup;
import org.eclipse.vjet.dsf.html.dom.DSelect;
import org.eclipse.vjet.dsf.html.dom.DTable;
import org.eclipse.vjet.dsf.html.dom.DTitle;
import org.eclipse.vjet.dsf.html.dom.DTr;
import org.eclipse.vjet.dsf.html.events.EventHandlerAttacher;
import org.eclipse.vjet.dsf.jsnative.HtmlArea;
import org.eclipse.vjet.dsf.jsnative.HtmlColgroup;
import org.eclipse.vjet.dsf.jsnative.HtmlDd;
import org.eclipse.vjet.dsf.jsnative.HtmlDocument;
import org.eclipse.vjet.dsf.jsnative.HtmlDt;
import org.eclipse.vjet.dsf.jsnative.HtmlFrameSet;
import org.eclipse.vjet.dsf.jsnative.HtmlInput;
import org.eclipse.vjet.dsf.jsnative.HtmlLegend;
import org.eclipse.vjet.dsf.jsnative.HtmlLi;
import org.eclipse.vjet.dsf.jsnative.HtmlOptGroup;
import org.eclipse.vjet.dsf.jsnative.HtmlOption;
import org.eclipse.vjet.dsf.jsnative.HtmlParam;
import org.eclipse.vjet.dsf.jsnative.HtmlSelect;
import org.eclipse.vjet.dsf.jsnative.HtmlTableCell;
import org.eclipse.vjet.dsf.jsnative.HtmlTableRow;



public class ANodeToDocument {
	/**
	 * The component can be any BaseHtmlElement and will end up being cloned 
	 * and properly parented so that a full DHtmlDocument results.  
	 */
	public static DHtmlDocument createHtmlDocumentContaining(Class<?> componentType, String appendElemId, String mtdCall) {
//		Node actualRoot = component;
//		while (actualRoot.getParentNode() != null) {
//			actualRoot = actualRoot.getParentNode();
//		}
		
		DHtmlDocument doc = null;
//		if (actualRoot instanceof HtmlDocument) {
//			doc = (DHtmlDocument) actualRoot;
//			return doc;
//		}
		
		// Need to create document
		doc = new DHtmlDocument();
		
		// If we have an HTML element it is added to the doc and displayed
//		if (actualRoot instanceof DHtml) {
//			//doc.appendChild(actualRoot) ;
//			return doc ;
//		}
		
		// Create the HTML element since its missing at this point
		DHtml html = new DHtml();
		doc.appendChild(html) ;
	
		// if actualRoot is a DHead we parent and can display
//		if (actualRoot instanceof DHead) {
//			html.appendChild(actualRoot);
//			return doc ;
//		}

		// to be well-form HTML document we need a HEAD - we add it here
		DHead head = new DHead();
		html.add(head);
				
		// if the actualRoot is a DTitle we add it to head and emit
//		if (actualRoot instanceof DTitle 
//			|| actualRoot instanceof DBase
//			|| actualRoot instanceof DLink
//			|| actualRoot instanceof DMeta
//			|| actualRoot instanceof DStyle)
//		{
//			head.appendChild(actualRoot) ;
//			return doc ;
//		}
		
		// We need a title in the head to be XHTML compliant
		DTitle title = new DTitle("Generated by VJ Runner");
		head.add(title);
		
		// if actualRoot is a BODY or FRAMESET we parent and can display
		if (componentType.equals(HtmlDocument.class)
				|| componentType.equals(HtmlFrameSet.class) 
				|| componentType.equals(void.class)) {
			callOnLoad(mtdCall);
			return doc;
		}
		
		// Need to handle special case of Frame only being parentable by Frameset
		if (componentType.equals(DFrame.class) || componentType.equals(DNoFrames.class)) {
			DFrameSet fs = new DFrameSet();
			fs.setHtmlId(appendElemId);
			html.appendChild(fs) ;
			appendCall(mtdCall, appendElemId);
			return doc ;
		}
		
		// At this point we have an element that must be further parented
		// to be hooked into the document.  We will assume that we are going
		// to add a BODY as that new attachment point.
		DBody body = new DBody();
		html.add(body);
		
		DNode forBodyParenting =
			getSuitableForBodyParenting(componentType, appendElemId, mtdCall);
		
		if (forBodyParenting == null) {
			addAppendCall(body, appendElemId, mtdCall);
//			body.add(EventType.CLICK, "alert('click')");
//			DA a = new DA("Click here");
//			a.setHtmlHref("#");
//			//a.add(EventType.CLICK, getJsCall(mtdCall, appendElemId));
//			String jsStr = "alert(1)";//getJsCall(mtdCall, appendElemId);
//			System.out.println(jsStr);
//			a.setHtmlOnClick(jsStr);
//			body.add(a);
//			DTextArea ta = new DTextArea();
//			ta.setHtmlRows(5).setHtmlCols(100).add(mtdCall);
//			body.add(ta);
		} else {
			body.appendChild(forBodyParenting);
		}
		return doc ;
	}	
	
	private static void callOnLoad(String mtdCall) {
		EventHandlerAttacher.addToBodyLoad(mtdCall);
	}
	
	private static void appendCall(String mtdCall, String elemId) {
		String sb = getJsCall(mtdCall, elemId);
		EventHandlerAttacher.addToBodyLoad(sb);
	}

	private static String getJsCall(String mtdCall, String elemId) {
		StringBuilder sb = new StringBuilder();
		sb.append("document.getElementById('").append(elemId).append("').appendChild(");
		sb.append(mtdCall).append(");");
		return sb.toString();
	}
	
	private static void addAppendCall(BaseCoreHtmlElement nd, String elemId, String mtdCall) {
		nd.setHtmlId(elemId);
		appendCall(mtdCall, elemId);
	}
	private static DNode getSuitableForBodyParenting(Class<?> componentType, String elemId, String mtdCall) {
		if (componentType.equals(HtmlInput.class)) {
			DForm form = new DForm() ;
			addAppendCall(form, elemId, mtdCall);
			return form ;
		}

		if (componentType.equals(HtmlArea.class)) {
			DMap map = new DMap() ;
			addAppendCall(map, elemId, mtdCall);
			return map ;
		}
		
		if (componentType.equals(HtmlColgroup.class)) {
			DTable table = new DTable().setHtmlWidth("500").setHtmlBorder("3") ;
			addAppendCall(table, elemId, mtdCall);
			return table ;
		}
		
		if (componentType.equals(HtmlDd.class)) {
			DDt ddt = new DDt() ;
			addAppendCall(ddt, elemId, mtdCall);
			return ddt ;
		}
		
		if (componentType.equals(HtmlLi.class)) {
			DOl dol = new DOl();
			dol.setHtmlType(DLi.TYPE_1) ;
			addAppendCall(dol, elemId, mtdCall);
			return dol;
		}
		
		if (componentType.equals(HtmlDt.class)) {
			DDl ddl = new DDl() ;
			addAppendCall(ddl, elemId, mtdCall);
			return ddl ;
		}

		// A few more special cases like LEGEND who should be owned by a FIELDSET
		// who should be owned by a FORM
		if (componentType.equals(HtmlLegend.class)) {
			DForm form = new DForm() ;
			DFieldSet fieldset = new DFieldSet() ;
			form.appendChild(fieldset) ;
			addAppendCall(form, elemId, mtdCall);
			return form ;
		}
				
		if (componentType.equals(HtmlSelect.class)) {
			DForm form = new DForm() ;
			addAppendCall(form, elemId, mtdCall);
			return form ;
		}
		
		if (componentType.equals(HtmlOptGroup.class)) {
			DForm form = new DForm() ;
			DSelect s = new DSelect() ;
			form.appendChild(s) ;
			addAppendCall(form, elemId, mtdCall);
			return form ;
		}
		
		if (componentType.equals(HtmlOption.class)) {
			DForm form = new DForm() ;
			DSelect s = new DSelect() ;
			DOptGroup g = new DOptGroup() ;
			form.appendChild(s) ;
			s.appendChild(g) ;
			addAppendCall(s, elemId, mtdCall);
			return form ;
		}		
		
		if (componentType.equals(HtmlParam.class)) {
			DObject object = new DObject() ;
			addAppendCall(object, elemId, mtdCall);
			return object ;
		}
		
//		if (c instanceof HtmlTable || c instanceof HtmlTHead || c instanceof DTFoot) {
//			DTable table = new DTable() ;
//			addAppendCall(table, elemId, mtdCall);
//			return table ;
//		}
		
		if (componentType.equals(HtmlTableRow.class)) {
			DTable table = new DTable().setHtmlBorder("3") ;
			addAppendCall(table, elemId, mtdCall);
			return table ;
		}
		
		if (componentType.equals(HtmlTableCell.class)) {
			DTable table = new DTable().setHtmlBorder("3") ;
			DTr tr = new DTr() ;
			table.appendChild(tr) ;
			addAppendCall(tr, elemId, mtdCall);
			return table ;
		}
		
		/*
		We need to see if the passed in BaseHtmlElement can be directly
		parented by a BODY element.  The following is directly from the HTML DTD
		*/
		// <!ELEMENT BODY O O (%flow;)* +(INS|DEL) -- document body -->
//		if (c instanceof IDFlow || c instanceof DDel) {
//			return c;
//		}
			
		// At this point we are neither meet nor cheese (Document or BaseHtmlElement)
		// We are then in the realm of DNode types...
		
		//callOnLoad(mtdCall);
		return null;
			
	}

}
